import { H as HighlighterGeneric, o as HighlighterCoreOptions, p as BundledHighlighterOptions, L as LanguageInput, j as ThemeInput, C as CodeToHastOptions, R as Root, b as RequireKeys, c as CodeToThemedTokensOptions, T as ThemedToken, d as CodeToTokensWithThemesOptions, e as ThemedTokenWithVariants, i as MaybeArray, Z as Element, n as ShikiInternal, y as ThemeRegistration, x as ThemeRegistrationRaw } from './langs.mjs';

type HighlighterCore = HighlighterGeneric<never, never>;
declare function getHighlighterCore(options?: HighlighterCoreOptions): Promise<HighlighterCore>;

type GetHighlighterFactory<L extends string, T extends string> = (options?: BundledHighlighterOptions<L, T>) => Promise<HighlighterGeneric<L, T>>;
/**
 * Create a `getHighlighter` function with bundled themes and languages.
 *
 * @param bundledLanguages
 * @param bundledThemes
 * @param ladWasm
 */
declare function createdBundledHighlighter<BundledLangs extends string, BundledThemes extends string>(bundledLanguages: Record<BundledLangs, LanguageInput>, bundledThemes: Record<BundledThemes, ThemeInput>, ladWasm: HighlighterCoreOptions['loadWasm']): GetHighlighterFactory<BundledLangs, BundledThemes>;
declare function createSingletonShorthands<L extends string, T extends string>(getHighlighter: GetHighlighterFactory<L, T>): {
    getSingletonHighlighter: () => Promise<HighlighterGeneric<L, T>>;
    codeToHtml: (code: string, options: CodeToHastOptions<L, T>) => Promise<string>;
    codeToHast: (code: string, options: CodeToHastOptions<L, T>) => Promise<Root>;
    codeToThemedTokens: (code: string, options: RequireKeys<CodeToThemedTokensOptions<L, T>, 'theme' | 'lang'>) => Promise<ThemedToken[][]>;
    codeToTokensWithThemes: (code: string, options: RequireKeys<CodeToTokensWithThemesOptions<L, T>, 'themes' | 'lang'>) => Promise<ThemedTokenWithVariants[][]>;
};

declare function isPlaintext(lang: string | null | undefined): boolean;
declare function toArray<T>(x: MaybeArray<T>): T[];
declare function isSpecialLang(lang: string): boolean;
declare function addClassToHast(node: Element, className: string | string[]): void;

/**
 * Get the minimal shiki context for rendering.
 */
declare function getShikiInternal(options?: HighlighterCoreOptions): Promise<ShikiInternal>;
/**
 * @deprecated Use `getShikiInternal` instead.
 */
declare const getShikiContext: typeof getShikiInternal;

declare function tokenizeAnsiWithTheme(theme: ThemeRegistration, fileContents: string): ThemedToken[][];

declare function toShikiTheme(rawTheme: ThemeRegistrationRaw | ThemeRegistration): ThemeRegistration;

export { type GetHighlighterFactory as G, type HighlighterCore as H, getShikiContext as a, toShikiTheme as b, getHighlighterCore as c, createdBundledHighlighter as d, createSingletonShorthands as e, toArray as f, getShikiInternal as g, isSpecialLang as h, isPlaintext as i, addClassToHast as j, tokenizeAnsiWithTheme as t };
