import{_ as a,o as t,c as e,R as o}from"./chunks/framework.TbLI3deC.js";const u=JSON.parse('{"title":"float 的基本内容","description":"","frontmatter":{},"headers":[],"relativePath":"notes/float.md","filePath":"notes/float.md"}'),l={name:"notes/float.md"},r=o('<h1 id="float-的基本内容" tabindex="-1">float 的基本内容 <a class="header-anchor" href="#float-的基本内容" aria-label="Permalink to &quot;float 的基本内容&quot;">​</a></h1><h2 id="float-元素与文档流" tabindex="-1">float 元素与文档流 <a class="header-anchor" href="#float-元素与文档流" aria-label="Permalink to &quot;float 元素与文档流&quot;">​</a></h2><p>脱离文档流</p><h2 id="float-元素和周边元素" tabindex="-1">float 元素和周边元素 <a class="header-anchor" href="#float-元素和周边元素" aria-label="Permalink to &quot;float 元素和周边元素&quot;">​</a></h2><p>仍然和周边元素正常互动，文本和 inline 元素会包裹在 float 元素周围，多个 float 按正常顺序先后排列，太宽就会换行</p><h2 id="高度塌陷" tabindex="-1">高度塌陷 <a class="header-anchor" href="#高度塌陷" aria-label="Permalink to &quot;高度塌陷&quot;">​</a></h2><p>容器也不会自动调整自己的高度，所以实际元素脱离文档流之后可能会被自动认为容器里空了，所以高度没有了，就高度塌陷了</p><h2 id="高度塌陷问题的解决" tabindex="-1">高度塌陷问题的解决 <a class="header-anchor" href="#高度塌陷问题的解决" aria-label="Permalink to &quot;高度塌陷问题的解决&quot;">​</a></h2><p>一般就是在容器里随便多搞一个加一个 clear 样式，简单但是不实用 一个常用的 hack 是选中高度塌陷元素的 after 伪元素 加上 clear，随意 content（空的就行）以及任意 block 展示，来确保 after 伪元素生成的新元素撑起来这个高度 float 搞左右布局就是两个大容器分别 float 左右，某种意义上还挺好懂，当然要确定宽高，才好</p>',9),n=[r];function f(i,c,s,h,d,_){return t(),e("div",null,n)}const m=a(l,[["render",f]]);export{u as __pageData,m as default};
