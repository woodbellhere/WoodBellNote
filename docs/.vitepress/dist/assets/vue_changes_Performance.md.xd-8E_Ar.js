import{_ as l,o as i,c as e,R as a}from"./chunks/framework.OFllvWJp.js";const m=JSON.parse('{"title":"vue3 的变化与优化","description":"","frontmatter":{},"headers":[],"relativePath":"vue/changes&Performance.md","filePath":"vue/changes&Performance.md"}'),t={name:"vue/changes&Performance.md"},r=a('<h1 id="vue3-的变化与优化" tabindex="-1">vue3 的变化与优化 <a class="header-anchor" href="#vue3-的变化与优化" aria-label="Permalink to &quot;vue3 的变化与优化&quot;">​</a></h1><h2 id="前端框架的通用价值-不论-vue-还是-react" tabindex="-1">前端框架的通用价值（不论 vue 还是 react） <a class="header-anchor" href="#前端框架的通用价值-不论-vue-还是-react" aria-label="Permalink to &quot;前端框架的通用价值（不论 vue 还是 react）&quot;">​</a></h2><ul><li>框架的优点</li><li>html 不灵活，需要反复复制</li><li>css 和 javascript 命名重复冲突</li><li>html 和 js 强耦合</li><li>数据不同步</li></ul><h2 id="vue-的基本特征" tabindex="-1">vue 的基本特征 <a class="header-anchor" href="#vue-的基本特征" aria-label="Permalink to &quot;vue 的基本特征&quot;">​</a></h2><ul><li>大致特点</li><li>渐进式</li><li>模板语法</li><li>数据和视图同步</li><li>组件化与独立组件</li></ul><h2 id="vue2-老问题与-vue3-新目标" tabindex="-1">vue2 老问题与 vue3 新目标 <a class="header-anchor" href="#vue2-老问题与-vue3-新目标" aria-label="Permalink to &quot;vue2 老问题与 vue3 新目标&quot;">​</a></h2><h3 id="代码架构" tabindex="-1">代码架构 <a class="header-anchor" href="#代码架构" aria-label="Permalink to &quot;代码架构&quot;">​</a></h3><ul><li>所以迁移到 typescript，自动生成类型声明</li><li>重新设计内部模块的分层</li><li>为长期维护打好基础</li></ul><h3 id="性能优化空间" tabindex="-1">性能优化空间 <a class="header-anchor" href="#性能优化空间" aria-label="Permalink to &quot;性能优化空间&quot;">​</a></h3><ul><li>编译器性能一般</li><li>所以重写 v-dom 的算法</li><li>结合编译器对 v-dom 进行优化</li><li>优化组件实例化的开销</li></ul><h3 id="api-在大型项目中的可维护性" tabindex="-1">api 在大型项目中的可维护性 <a class="header-anchor" href="#api-在大型项目中的可维护性" aria-label="Permalink to &quot;api 在大型项目中的可维护性&quot;">​</a></h3><ul><li>选项式 api 在大项目中举步维艰</li><li>引入对重构，复用和类型推导更友好的组合式 api</li></ul><h3 id="浏览器版本限制" tabindex="-1">浏览器版本限制 <a class="header-anchor" href="#浏览器版本限制" aria-label="Permalink to &quot;浏览器版本限制&quot;">​</a></h3><ul><li>vue2 支持 ie9，现在 没必要了</li><li>现在支持最低 es2015</li></ul><h2 id="vue3-新特性-也基本是新优化" tabindex="-1">vue3 新特性（也基本是新优化） <a class="header-anchor" href="#vue3-新特性-也基本是新优化" aria-label="Permalink to &quot;vue3 新特性（也基本是新优化）&quot;">​</a></h2><h3 id="数据劫持优化" tabindex="-1">数据劫持优化 <a class="header-anchor" href="#数据劫持优化" aria-label="Permalink to &quot;数据劫持优化&quot;">​</a></h3><ul><li>object.defineProperty 需要预先确定拦截的 key/属性</li><li>嵌套复杂的多层对象就需要递归调用 defineproperty，性能负担大</li><li>vue3 用 proxy，劫持整个对象，无所谓属性</li><li>但也不能监听深层对象，需要显示指定递归调用</li><li>object.defineProperty 的 get 和 set <ul><li>处理数组是重写方法</li></ul></li><li>proxy - 对数组更友好，且能监听到数组属性</li></ul><h3 id="编译优化" tabindex="-1">编译优化 <a class="header-anchor" href="#编译优化" aria-label="Permalink to &quot;编译优化&quot;">​</a></h3><ul><li><p>new vue -&gt; init() -&gt; $mount -&gt; compile -&gt; render() -&gt; vnode -&gt; patch -&gt; DOM</p></li><li><p>vue 的更新颗粒度是组件级别的，但很多时候我们只需要更新一个组件内的少数响应性数据，但原有的 vue2 内部依然需要循环和递归遍历 vnode 树来保证大家都更新了。但理想状态下，diff 应该能明确指向确实需要响应式变化的具体标签，其他就不用变</p></li><li><p>vue3 搞出了 block tree，能让 vnode 更新从遍历整个模板变为只和动态变化内容相关</p><ul><li>block tree 是一个将模板基于动态节点（有响应式变化的标签）指令切割的嵌套区块，每个区块内部的节点结构固定</li><li>每个区块只需要一个 array 来追踪自身包含的动态节点</li></ul></li><li><p>运行时 diff 算法重写</p><ul><li>v-dom 性能优化</li><li>从处理后的源码看，主要是对响应式的内容打 path flag 标记，准备更新</li><li>而且 flag 都用位运算</li></ul></li><li><p>slot 优化</p></li><li><p>事件监听函数的缓存优化</p></li></ul><h3 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h3><ul><li><p>源码体积</p></li><li><p>移除部分无用 api，inline，filter，</p></li><li><p>引入 tree-shaking</p></li><li><p>tree-shaking</p></li><li><p>编译阶段的静态分析就能找出没用到的模块并打标记</p></li></ul><h3 id="源码优化" tabindex="-1">源码优化 <a class="header-anchor" href="#源码优化" aria-label="Permalink to &quot;源码优化&quot;">​</a></h3><ul><li><p>monorepo 管理文件</p></li><li><p>ts 开发源码</p></li><li><p>目的是提高代码的维护性和可开发性</p></li><li><p>monorepo 代码管理</p></li><li><p>将模块拆分到不同 package 中，每个 packages 均有各自的 api，类型定义和测试</p></li><li><p>使得整体模块划分更为细致，职责更清晰，依赖关系也更明显</p></li><li><p>读起来，写起来，改起来更方便</p></li><li><p>ts 开发</p></li><li><p>类型检查</p></li><li><p>类型定义和 ide 提示</p></li></ul><h3 id="语法优化" tabindex="-1">语法优化 <a class="header-anchor" href="#语法优化" aria-label="Permalink to &quot;语法优化&quot;">​</a></h3><ul><li>composition api</li><li>options api 是一个“一个对象，包含了描述组件属性的选项”</li><li>逻辑复用从 mixin 变为 composition，命名冲突和来源不清晰 重写双向数据绑定</li></ul><h3 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-label="Permalink to &quot;API&quot;">​</a></h3><ul><li>加入 fragments <ul><li>可以写多个根节点，不像 vue2 只能写一个包住其他</li><li>实现方式是加虚拟节点，这些节点并不会渲染</li></ul></li><li>支持 jsx 和 tsx</li><li>支持 suspense teleport 组件以及多 v-model 用法</li></ul>',27),o=[r];function u(n,h,p,s,c,d){return i(),e("div",null,o)}const f=l(t,[["render",u]]);export{m as __pageData,f as default};
