import{_ as l,o as e,c as t,R as a}from"./chunks/framework.mPPLtEmG.js";const p=JSON.parse('{"title":"css 解析的大致过程","description":"","frontmatter":{},"headers":[],"relativePath":"browser/cssParse.md","filePath":"browser/cssParse.md"}'),s={name:"browser/cssParse.md"},i=a('<h1 id="css-解析的大致过程" tabindex="-1">css 解析的大致过程 <a class="header-anchor" href="#css-解析的大致过程" aria-label="Permalink to &quot;css 解析的大致过程&quot;">​</a></h1><h2 id="w3c-连图都没有-太垃了" tabindex="-1">w3c 连图都没有，太垃了 <a class="header-anchor" href="#w3c-连图都没有-太垃了" aria-label="Permalink to &quot;w3c 连图都没有，太垃了&quot;">​</a></h2><p>但从文档来看，大致过程和 html 解析是基本一样的</p><h2 id="粗线条的过程描述" tabindex="-1">粗线条的过程描述 <a class="header-anchor" href="#粗线条的过程描述" aria-label="Permalink to &quot;粗线条的过程描述&quot;">​</a></h2><ul><li>也首先从网络或者本地接收文件</li><li>浏览器将这道 二进制字节流 按照特定的 字符编码方式解码为码点 <ul><li>期间需要确定 fallback/保底编码方式 <ul><li>http 或者 html 的 http 头里指定就用</li></ul></li><li>实际解码然会返回，一般默认返回 utf-8，但是实际的编码情况挺多</li></ul></li><li>预处理，也是类似的标准化 <ul><li>也是把换行符都替换为 utf-lf</li><li>以及把 utf-null 换成 utf- fffd</li></ul></li><li>进入分词阶段 <ul><li>这个过程似乎也跟 html 解析用状态即差不多</li><li>将连续的字节流拆分为一系列独立 tokne，并将配对好的 tokne 返回字节流</li></ul></li><li>进入 parsing/tree construction 阶段 <ul><li>将 token 流解析为具体的 css 语法 <ul><li>主要是区分不同类型的语法，比如一条 rule，一个声明等等</li></ul></li></ul></li><li>返回一个 cssStyleSheet 对象</li></ul>',5),r=[i];function c(o,n,u,h,_,d){return e(),t("div",null,r)}const m=l(s,[["render",c]]);export{p as __pageData,m as default};
