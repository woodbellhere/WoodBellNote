import{_ as i,o as l,c as a,R as s}from"./chunks/framework.OFllvWJp.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vue/VueAlog.md","filePath":"vue/VueAlog.md"}'),e={name:"vue/VueAlog.md"},t=s(`<h2 id="diff-算法的文字性解释-vue-里其他算法性的也往这里放" tabindex="-1">Diff 算法的文字性解释（vue 里其他算法性的也往这里放） <a class="header-anchor" href="#diff-算法的文字性解释-vue-里其他算法性的也往这里放" aria-label="Permalink to &quot;Diff 算法的文字性解释（vue 里其他算法性的也往这里放）&quot;">​</a></h2><h2 id="v-dom-虚拟-dom-和-diff-算法" tabindex="-1">v-dom 虚拟 DOM 和 diff 算法 <a class="header-anchor" href="#v-dom-虚拟-dom-和-diff-算法" aria-label="Permalink to &quot;v-dom 虚拟 DOM 和 diff 算法&quot;">​</a></h2><ul><li>v-dom 虚拟 DOM</li><li>通过 js 生成一个 ast 节点树/用对象模仿 dom 属性</li><li>dom 是内容很重的数据，操作起来容易浪费性能</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;item in a&#39;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> :key=&#39;xxx&#39;&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{{ item }}</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">&lt;/div&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">&lt;script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const a = [&#39;wood&#39;, &#39;bell&#39;, &#39;woodbell&#39;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a.splice(2,0, &#39;DDD&#39;)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="diff-算法" tabindex="-1">diff 算法 <a class="header-anchor" href="#diff-算法" aria-label="Permalink to &quot;diff 算法&quot;">​</a></h2><h3 id="无-key-算法" tabindex="-1">无 key 算法 <a class="header-anchor" href="#无-key-算法" aria-label="Permalink to &quot;无 key 算法&quot;">​</a></h3><ul><li>patchUnkeyedChildren 函数</li><li>其中有 c1 旧的 v-node 和 c2 新的 v-node 两个参数</li><li>第一步 遍历两个数组，新旧对比并且让新替换旧</li><li>第二步 发现多的节点就新增</li><li>第三步 发现少了就删除</li></ul><h3 id="有-key-算法-最长递增子序列" tabindex="-1">有 key 算法，最长递增子序列 <a class="header-anchor" href="#有-key-算法-最长递增子序列" aria-label="Permalink to &quot;有 key 算法，最长递增子序列&quot;">​</a></h3><ul><li>patchKeyedChildren 函数</li><li>一样有 c1 和 c2 两个旧新节点数组</li><li>第一步 前序算法/先从头比较两个节点数组</li><li>比较使用 isSameVNodeType 函数，主要是比较 type（是不是 div 这种）和 key，都一样才返回 true</li><li>第二步 比较中出现不同时则跳出，进行尾序对比，从后比较两个节点数组</li><li>第三步 又发现不同的新节点则新增</li><li>第四步 发现少了相同节点旧删除/卸载</li><li>第五步 乱序时，比如新增删除位移同时发生，比如 input 框</li><li>第一步 构建新节点的映射关系</li><li>key 是 12345，索引就是 01234，排序后 key 是 54321， 索引其实也不变， 实际上形成 key 和索引之间的 map 关系</li><li>第二步 新节点 在旧节点中位置 的一个数组， 有多余就删掉，不包含旧节点也删掉</li><li>如果节点交叉，就要用最长递增子序列做 move 是否 true 的判断</li><li>第三步 开始最长递增子序列的对比</li><li>首先进行一个贪心加二分查找结合的算法来求最长递增子序列</li><li>如果在子序列中就要移动节点</li><li>不在就跳过</li></ul><h3 id="vue2-的双端-diff" tabindex="-1">vue2 的双端 diff <a class="header-anchor" href="#vue2-的双端-diff" aria-label="Permalink to &quot;vue2 的双端 diff&quot;">​</a></h3><ul><li>先两两从头对比</li><li>再两两从尾部对比</li><li>接着两两头对比尾</li><li>最后两两尾对比头</li></ul><h2 id="nexttick" tabindex="-1">nextTick <a class="header-anchor" href="#nexttick" aria-label="Permalink to &quot;nextTick&quot;">​</a></h2><ul><li>将回调推迟到下一个 dom 更新周期后执行。</li><li>更改一些数据来等 dom 更新后马上使用</li><li>一个例子是每次给某个元素中加上 n 行文字，然后求此时元素高度</li><li>一般情况下需要 updated 钩子才能获取这个内容，一般脚本只能获取当前（未更新）的内容</li><li>但 update 钩子会在所有更新操作都触发，所以很多余</li><li>nexttick 函数提供了很好的专门工具，在 dom 正式更新之后拿到数据</li><li>相当于 nexttick 把操作加入到微任务队列最后</li><li>watch 这些也是用 nexttick 实现，比如一个循环加 1 一百次的函数，watch 或者 nexttick 最后都只会得到一个更新</li></ul>`,13),n=[t];function h(d,k,o,r,p,c){return l(),a("div",null,n)}const y=i(e,[["render",h]]);export{f as __pageData,y as default};
