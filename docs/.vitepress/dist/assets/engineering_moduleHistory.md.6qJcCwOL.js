import{_ as i,o as s,c as a,R as l}from"./chunks/framework.OFllvWJp.js";const u=JSON.parse('{"title":"前端过去如何实现模块化","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/moduleHistory.md","filePath":"engineering/moduleHistory.md"}'),e={name:"engineering/moduleHistory.md"},t=l(`<h1 id="前端过去如何实现模块化" tabindex="-1">前端过去如何实现模块化 <a class="header-anchor" href="#前端过去如何实现模块化" aria-label="Permalink to &quot;前端过去如何实现模块化&quot;">​</a></h1><h2 id="函数作用域的尝试" tabindex="-1">函数作用域的尝试 <a class="header-anchor" href="#函数作用域的尝试" aria-label="Permalink to &quot;函数作用域的尝试&quot;">​</a></h2><p>在 es6 规范推出 let 和 const 能够使用的 block 作用域之前，var 能够声明的只有全局变量和函数中的函数作用域变量<br> 因此直接利用这一局部作用域讲特定操作/功能组织到一起已经是一种模块化的雏形<br> 至于说这种写法下，封装函数功能和模块化相互基本无法区分，那只能说是没法强求的时代问题</p><h2 id="scirpt-文件模式" tabindex="-1">scirpt 文件模式 <a class="header-anchor" href="#scirpt-文件模式" aria-label="Permalink to &quot;scirpt 文件模式&quot;">​</a></h2><p>其核心就是 script 引入的文件即模块<br> 完全以约定为规范\\</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// module-A.js文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// module-B.js文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> method</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;execute method&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// index.html文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./module-A.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./module-B.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.log(data)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  method()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>缺点</p><ul><li>所有模块都使用全局作用域，污染全局</li><li>也容易产生命名冲突</li><li>无法管理模块依赖</li></ul><h2 id="命名空间时期" tabindex="-1">命名空间时期 <a class="header-anchor" href="#命名空间时期" aria-label="Permalink to &quot;命名空间时期&quot;">​</a></h2><p>模块只暴露一个全局对象，模块内容挂载到对象之下<br> 自然也就是将模块内容整个包裹起来，就形成了上面的全局对象<br> 缺点</p><ul><li>私有空间是假的</li><li>依赖关系仍然不清楚</li></ul><h2 id="life-时期" tabindex="-1">LIFE 时期 <a class="header-anchor" href="#life-时期" aria-label="Permalink to &quot;LIFE 时期&quot;">​</a></h2><p>用立即执行函数的方式包裹模块，来提供私有空间<br> 在函数内部就用.语法挂载到外部对象<br> 这些都算 script 引入时期<br> 缺点可能就是麻烦</p><h2 id="commonjs-规范走了第一步" tabindex="-1">CommonJS 规范走了第一步 <a class="header-anchor" href="#commonjs-规范走了第一步" aria-label="Permalink to &quot;CommonJS 规范走了第一步&quot;">​</a></h2><p>一个文件就是一个模块<br> 每个模块都有单独作用域，不会污染全局作用域<br> 模块可以被多次加载和引用，第一次加载时就会被缓<br> 通过 module.exports 导出成员,通过 require 函数载入模块<br> 输出的值是值的复制，因此不同其他文件引入模块后的修改不会影响模块自身<br> 模块按照引入顺序进行加载<br> 缺点</p><ul><li>同步执行</li><li>浏览器不能用</li></ul><h2 id="amd-异步模块定义" tabindex="-1">AMD 异步模块定义 <a class="header-anchor" href="#amd-异步模块定义" aria-label="Permalink to &quot;AMD 异步模块定义&quot;">​</a></h2><p>CJS 的主要问题是它本身没有考虑浏览器中常见的异步加载<br> 而响应使用浏览器要求的模块化规范是 requireJS<br> requireJS 仍然是通过 life 实现的，当然只要不自己写就都算方便<br> 通过 define 函数定义模块，模块依赖和模块私有空间的内容<br> 通过 require 函数加载模块，会自动创建 script 标签请求实现<br> 加载完成后，requireJS 会自动删除引入时的 script 标签 缺点</p><ul><li>写起来相对麻烦</li><li>模块划分一多就无数请求</li></ul><h2 id="整合性的-cmd-与-umd" tabindex="-1">整合性的 CMD 与 UMD <a class="header-anchor" href="#整合性的-cmd-与-umd" aria-label="Permalink to &quot;整合性的 CMD 与 UMD&quot;">​</a></h2><p>Common Module Definition<br> CMD 主要是整合了 cjs 和 AMD，整体和 require.js 大差不差，主要实现是 sea.js<br> CMD 和 AMD 的区别主要是\\</p><ul><li>AMD 纯粹是异步加载，CMD 异步同步都可以</li><li>AMD 是依赖前置，需要提前声明依赖；CMD 是就近依赖，使用前引入即可</li></ul><p>Universal Module Definition<br> 同时允许 AMD 和 CJS 规范<br> 核心实现是实时判断具体用什么模块规范，然后调用相应的 CJS 和 AMD 方法\\</p><h2 id="原生的-esm" tabindex="-1">原生的 ESM <a class="header-anchor" href="#原生的-esm" aria-label="Permalink to &quot;原生的 ESM&quot;">​</a></h2><p>使用直接在 script 标签中指定 type=module 即可 esmodule 的特点</p><ul><li>自动严格模式，忽略 use strict</li><li>module 都运行在独立的私有作用域</li><li>必须在文件顶部引入依赖</li><li>导出的变量类型收到严格限制</li><li>变量不允许重新绑定，且引入的模块名本身也需要是不可更改的字符串 常量</li><li>esmodule 是通过 cors 的方式请求外部 js 模块 <ul><li>需要服务端支持 cors</li></ul></li><li>不支持文件形式，只支持 httpServer</li><li>esmodule script 采取延迟执行 <ul><li>一般 script 是立即执行的</li></ul></li></ul><p>esm 和 cjs 等其他规范 相互之间</p><ul><li>cjs 是动态运行，只能在运行时确定，</li><li>esm 是静态编译，编译时即确定输入输出的内容，这俩是核心区别</li><li>esm 传值是传引用</li><li>cjs 传值是通过复制值</li><li>esmodule 可以导入 cjs</li><li>cjs 不能导入 esmodule</li><li>cjs 始终只会导出一个默认成员</li></ul><h2 id="说法很多的-tree-shaking-和-dce-先占个坑" tabindex="-1">说法很多的 Tree Shaking 和 DCE（先占个坑） <a class="header-anchor" href="#说法很多的-tree-shaking-和-dce-先占个坑" aria-label="Permalink to &quot;说法很多的 Tree Shaking 和 DCE（先占个坑）&quot;">​</a></h2><p>Tree Shaking 概念和实现的提出者 Rich Harris （同时也是 Svelte 和 RollUp 的发明者）对两个概念做过形象的对比<br> 假象一个打鸡蛋和面做蛋糕的场景。因为鸡蛋壳确实没啥用，所以在蛋糕制作中我们总是要想办法把鸡蛋壳清理出来。 Dead Code Elimination（DCE 死代码清除）就好像先把鸡蛋整个和到面里打碎，等到蛋糕做完了才把碎鸡蛋壳挑出来 Tree Shaking（摇树，其实挺形象的）就好像提前把鸡蛋敲开，把蛋白蛋清蛋液直接准备好和面用</p>`,31),n=[t];function h(p,r,k,d,o,E){return s(),a("div",null,n)}const g=i(e,[["render",h]]);export{u as __pageData,g as default};
