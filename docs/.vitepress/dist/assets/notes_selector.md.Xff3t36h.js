import{_ as e,o as a,c as t,R as o}from"./chunks/framework.mPPLtEmG.js";const s="/WoodBellNote/assets/selectoOrder.nUHKmybW.png",f=JSON.parse('{"title":"css 选择器","description":"","frontmatter":{},"headers":[],"relativePath":"notes/selector.md","filePath":"notes/selector.md"}'),r={name:"notes/selector.md"},l=o('<h1 id="css-选择器" tabindex="-1">css 选择器 <a class="header-anchor" href="#css-选择器" aria-label="Permalink to &quot;css 选择器&quot;">​</a></h1><h1 id="选择器顺序图解" tabindex="-1">选择器顺序图解 <a class="header-anchor" href="#选择器顺序图解" aria-label="Permalink to &quot;选择器顺序图解&quot;">​</a></h1><p><img src="'+s+'" alt="Selector Order"></p><h1 id="选择器的基本思路" tabindex="-1">选择器的基本思路 <a class="header-anchor" href="#选择器的基本思路" aria-label="Permalink to &quot;选择器的基本思路&quot;">​</a></h1><p>元素本身 手动对元素分类/包括 id 和 class 根据元素属性选择 :状态选择 伪类选择 ，不如叫扩展类，只是扩充了一些常见状态 重要状态之外 元素中第 n 个 元素中某类的第 n 个 （还包括倒数第 n 个） ::伪元素 也可以叫扩展元素嗷，就是对选中元素做更细致的调整，里面还有选中首字符，一看就是首行锁进大小写啥的 :root 伪类选择器等价于 html 的 tag 选择器</p><h1 id="选择器的结合方式有一些基本思路" tabindex="-1">选择器的结合方式有一些基本思路 <a class="header-anchor" href="#选择器的结合方式有一些基本思路" aria-label="Permalink to &quot;选择器的结合方式有一些基本思路&quot;">​</a></h1><p>分组选择，同时选中一群不一样的元素使用一套样式 多条件选择，使一个元素能适应不同的样式选择 关系选择 考虑纵向的代际代数，和横向的亲缘广度</p><ul><li>（纵向 n 代）后代选择 空格，在空格前选择器的范围中筛选空格后选择器</li><li>（纵向 1 代）父子选择 &gt;</li><li>（横向下 1 个）兄弟姐妹选择 +</li><li>（横向下 n 个）通用兄弟选择 ~</li><li>（父子选择迂回处理，基本上是手动指定兄 class）向上反选哥哥</li></ul><h1 id="继承沿着-dom-实现-所以渲染顺序跟这个肯定也有关系" tabindex="-1">继承沿着 DOM 实现，所以渲染顺序跟这个肯定也有关系 <a class="header-anchor" href="#继承沿着-dom-实现-所以渲染顺序跟这个肯定也有关系" aria-label="Permalink to &quot;继承沿着 DOM 实现，所以渲染顺序跟这个肯定也有关系&quot;">​</a></h1>',9),i=[l];function c(n,d,h,_,m,p){return a(),t("div",null,i)}const b=e(r,[["render",c]]);export{f as __pageData,b as default};
