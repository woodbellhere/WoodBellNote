import{_ as a,o as e,c as t,R as o}from"./chunks/framework.OFllvWJp.js";const u=JSON.parse('{"title":"布局和文档流的基本认识","description":"","frontmatter":{},"headers":[],"relativePath":"notes/layout&flow.md","filePath":"notes/layout&flow.md"}'),r={name:"notes/layout&flow.md"},i=o('<h1 id="布局和文档流的基本认识" tabindex="-1">布局和文档流的基本认识 <a class="header-anchor" href="#布局和文档流的基本认识" aria-label="Permalink to &quot;布局和文档流的基本认识&quot;">​</a></h1><h1 id="文档流和块" tabindex="-1">文档流和块 <a class="header-anchor" href="#文档流和块" aria-label="Permalink to &quot;文档流和块&quot;">​</a></h1><p>符合文档流的块基本可以按空格/间隔/逻辑断开设置 div，并且可以一层一层合并化简 不符合文档流的就单独设置 div 页面划分出来之后，再考虑语义元素替换</p><h1 id="基于块的布局意识" tabindex="-1">基于块的布局意识 <a class="header-anchor" href="#基于块的布局意识" aria-label="Permalink to &quot;基于块的布局意识&quot;">​</a></h1><p>比如说，块级总体只需要考虑上下，所以第一眼就看整个网页能分几个上下几个 div 然后每一个大块里再看小块的流向，如果都是符合流的从左到右/从右到左，那么维持原样 如果有一些小块打断流，比如明明在从左到右一块一块安排，你突然来了一块内容上下排布的，那么它就单列一个 div，同时受它影响的正常流块业需要设置 div 这样一轮把网页化简为 n 个 div 套 div 再说</p><h1 id="gap-属性在控制间隔上的相比-margin-的优势" tabindex="-1">gap 属性在控制间隔上的相比 margin 的优势 <a class="header-anchor" href="#gap-属性在控制间隔上的相比-margin-的优势" aria-label="Permalink to &quot;gap 属性在控制间隔上的相比 margin 的优势&quot;">​</a></h1><p>gap 可能要比 margin 更符合设计需求 margin 是以元素为中心四周向外增加空白 gap 似乎只在意一般意义上的行列间距，所以不会像 margin 一样多出四周无用的空白</p>',7),n=[i];function l(d,s,_,c,h,p){return e(),t("div",null,n)}const f=a(r,[["render",l]]);export{u as __pageData,f as default};
