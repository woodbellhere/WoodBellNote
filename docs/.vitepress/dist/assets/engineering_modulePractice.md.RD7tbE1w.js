import{_ as e,o as i,c as t,k as l,a,R as r}from"./chunks/framework.OFllvWJp.js";const k=JSON.parse('{"title":"模块的常用操作","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/modulePractice.md","filePath":"engineering/modulePractice.md"}'),o={name:"engineering/modulePractice.md"},x=l("h1",{id:"模块的常用操作",tabindex:"-1"},[a("模块的常用操作 "),l("a",{class:"header-anchor",href:"#模块的常用操作","aria-label":'Permalink to "模块的常用操作"'},"​")],-1),n=l("ul",null,[l("li",null,"因为所有内容都在私有作用域中，需要明确引入和导出")],-1),s=l("h2",{id:"导出方式",tabindex:"-1"},[a("导出方式 "),l("a",{class:"header-anchor",href:"#导出方式","aria-label":'Permalink to "导出方式"'},"​")],-1),d=l("ul",null,[l("li",null,"export 和 import + 各类声明 let function class 等"),l("li",{"xxx1,":"","xxx2,xxxx":""},"export 和 import + 声明好的变量名"),l("li",{xxx1:"",as:"",yyy1:""},"可在 export 和 import 时赋予别名 export"),l("li",null,[a("export default 的对象成为默认导出，导入时则默认接收这部分内容 "),l("ul",null,[l("li",null,"一种经验是 export xxx 给整个模块起个喜欢的名字，这样 导入时就可以随你喜欢")])])],-1),c=r('<h2 id="导入和导出时的大括号" tabindex="-1">导入和导出时的大括号 <a class="header-anchor" href="#导入和导出时的大括号" aria-label="Permalink to &quot;导入和导出时的大括号&quot;">​</a></h2><ul><li>不是对象语法，而是特定的模块语法，导出不是对象字面量，引入也不是解构</li><li>export default + 大括号，基本就是一个对象了</li></ul><h2 id="引入方式" tabindex="-1">引入方式 <a class="header-anchor" href="#引入方式" aria-label="Permalink to &quot;引入方式&quot;">​</a></h2><ul><li>import * as xxx from &#39;./xxx&#39; 获取模块全部内容并放入 xxx 对象中</li><li>命名成员正常 {}引入</li><li>默认成员需要用 as，也可以在{}外直接引入</li><li>命名成员和默认成员可以在{}中按要求同时导入，也可以在{}内外分别引入</li><li>import defaultX, {xxx1, xxx2} from &#39;./xxx&#39;</li></ul><h2 id="导入导出是复制还是引用" tabindex="-1">导入导出是复制还是引用 <a class="header-anchor" href="#导入导出是复制还是引用" aria-label="Permalink to &quot;导入导出是复制还是引用&quot;">​</a></h2><ul><li>是引用，在引入处表现为只读常量，无法修改</li><li>可以通过在导入和导出处各自一个定时器检查读写变化来实现</li></ul><h2 id="引入的地址要求" tabindex="-1">引入的地址要求 <a class="header-anchor" href="#引入的地址要求" aria-label="Permalink to &quot;引入的地址要求&quot;">​</a></h2><ul><li>必须把后缀/扩展名写全，只是在打包工具支持下可以省略</li><li>需要补全./或者使用/xxx 指定根目录</li><li>可以指定一个完整的网络 url，可以引 cdn</li><li>通过引入运行模块，而非使用具体的数据 <ul><li>import {} from &#39;./xxx&#39;即可只运行模块</li><li>可简写为 import &#39;./xxx&#39; 直接省略指定数据部分</li></ul></li></ul><h2 id="动态引入与引入的条件和时机" tabindex="-1">动态引入与引入的条件和时机 <a class="header-anchor" href="#动态引入与引入的条件和时机" aria-label="Permalink to &quot;动态引入与引入的条件和时机&quot;">​</a></h2><ul><li>import from 实际是静态的，不能在运行时根据条件判断按需引入</li><li>import()函数实现了这个功能</li></ul><h2 id="导入后直接导出" tabindex="-1">导入后直接导出 <a class="header-anchor" href="#导入后直接导出" aria-label="Permalink to &quot;导入后直接导出&quot;">​</a></h2><ul><li>export {xxx1, xxx2} from &#39;./xxx&#39;</li></ul><h2 id="集中导出的开发经验" tabindex="-1">集中导出的开发经验 <a class="header-anchor" href="#集中导出的开发经验" aria-label="Permalink to &quot;集中导出的开发经验&quot;">​</a></h2><ul><li>当需要导入导出的数据较为繁琐时</li><li>可以在某个文件（比如 index.js）中集中导入再导出</li></ul>',14),u=[x,n,s,d,c];function h(m,_,p,f,b,P){return i(),t("div",null,u)}const g=e(o,[["render",h]]);export{k as __pageData,g as default};
