import{_ as i,o as s,c as a,R as l}from"./chunks/framework.OFllvWJp.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"todo/vueRouter.md","filePath":"todo/vueRouter.md"}'),p={name:"todo/vueRouter.md"},t=l(`<ul><li><p>vue 是一种单页应用</p></li><li><p>但你大可以把页面本身当组件</p></li><li><p>用页面 path 当动态组件的绑定对象，</p></li><li><p>手动维护这些路由容易出错</p></li><li><p>vue router 就是一种声明式使用路由的方法</p></li><li><p>直接生成一个包含不同页面路径的对象</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> routes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    component: PageOne,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    label: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;页面1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;/2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    component: PageTwo,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    label: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;页面2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;/3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    component: PageThree,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    label: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;页面3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li><li><p>实时监听“当前路径”在哪里</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> currentPath</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location.pathname);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> currentPage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> computee</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes[currentPath.value].component </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PageOne;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  &lt;!--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 设置默认页 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p>将页面当作动态组件使用</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">nav</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> :href=&quot;path&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;(route, path) in routes&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {{ route.label }}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">nav</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">component</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> :is=&quot;currentPage&quot;&gt;&lt;/component&gt;</span></span></code></pre></div></li><li><p>利用 history api 来处理页面跳转刷新</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> changeRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  history.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pushState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, path);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  currentPath.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> location.pathname;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>vue route 自己</p></li><li><p>单独定义一个 route.js 文件</p></li><li><p>路由现在放在一个对象数组里</p></li><li><p>引入 createRouter 来定义一个路由实例对象</p></li><li><p>引入 createWebHistory（也可以哈希）在实例对象中作为 history 配置项</p></li><li><p>在路由实例对象中引入路由数组</p></li><li><p>并在 main.js 入口文件 use 一下这个路由文件（express）狂喜</p></li><li><p>router-view 根据路径数组来渲染当前路径下的组件</p></li><li><p>嵌套路由</p></li><li><p>就是在路由数组的对象中再加一个 children，它本身又是一个标准路由</p></li><li><p>路由管理中的动态路由</p></li><li><p>在路由对象的 path 部分也可以传 v-bind 的路径</p></li><li><p>此后可以通过 this.$route.params.postid 访问到</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/:postId&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: BlogPostPage,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">article</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;blogPost in blogPosts&quot;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> :key=&quot;blogPost.id&quot;&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  &lt;h2&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    &lt;router-link</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> :to=&quot;\`/\${blogPost.id}\`&quot;&gt;{{</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">      blogPost.title</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    }}&lt;/router-link&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  &lt;/h2&gt;</span></span></code></pre></div></li><li><p>动态路由间的冲突</p></li><li><p>动态路由使用同一个组件实例展示（用 is 动态变化嘛），路径在动态路由之间跳转就相当于在同一个组件内反复横跳</p></li><li><p>因此只是复用组件实例，但是问题就是破坏生命周期正常活动，因为组件只在创建和销毁时执行一次，导致跳转应该有的重新创建操作失效</p></li><li><p>跟 key 的作用差不多</p></li><li><p>解决方法就是把生命周期操作换成 watch,这样路径变化就是必须要处理的正常操作</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;$route.params&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">params</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldParams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.blogPost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getBlogPostById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(params.postId);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    immediate: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>或者直接在生命周期钩子中使用 this.$route.params</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">created</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$route.params,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">params</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldParams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.blogPost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getBlogPostById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(params.postId);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {immediate:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>多个动态参数拼接时</p></li><li><p>比如说 /user/:userid/posts/:postid</p></li><li><p>查询每个用户所发的帖子</p></li><li><p>可以通过 this.$route.params 来获取</p></li><li><p>当有多个重复/数量不固定 url 时</p></li><li><p>如 goods/t-shirts/xshape 这种</p></li><li><p>就需要用+*？这些看起来很正则的办法来实现(且只能用在动态路由中)</p><ul><li>+至少出现一次 <ul><li>/:kind+ 就可以是 /kind 或者 /kind/t-shirts</li></ul></li><li>*出现任意次 <ul><li>/:kind* 就可以是 /kind /kind/t-shirts 甚至 /</li></ul></li><li>? 出现 0-1 次 <ul><li>/:kind? /kind /kind/t-shirts /</li></ul></li><li>/:notFound(.*)/* 统一的 404 路由</li></ul></li><li><p>路由间的优先级</p></li><li><p>跟 css 选择器风格差不多，越精确的优先级越高</p></li><li><p>同级的前面的优先</p></li><li><p>有 path ranker 这种小工具可以看优先级</p></li><li><p>查询字符串形式</p></li><li><p>可以通过$route.query 获取</p></li><li><p>?后就是正式的 query 字段，基本按照 key=value 的形式组成，多个键值对按照 &amp; 拼接</p></li><li><p>命名路由</p></li><li><p>可以在路由对象中多加 name 属性，可以避免有歧义的路由</p></li><li><p>在 router-link to 中可以按照对象形式传参，明确指定传哪个路由</p></li><li><p>路由别名</p></li><li><p>相同的 url 渲染相同的页面</p></li><li><p>比如 home 页和 index 页都指向/页</p></li><li><p>需要在路由对象中设置 alias 属性，按数组形式传参</p></li><li><p>需要注意，如果路径本身是动态参数，则别名中也需要加上这段动态参数</p></li><li><p>路由重定向</p></li><li><p>路由对象中设置 redirect 即可，也不需要设置 component</p></li><li><p>也可以在 redirect 中传一个命名路由的名字，则直接按命名重定向</p></li><li><p>动态路由需要用相当麻烦的办法</p></li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/posts/:postId&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    redirect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`/\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">params</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">postId</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><ul><li><p>编程式导航</p></li><li><p>可以内联事件监听来跳转页面</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">click</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`/\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">blogPost</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">id</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;查看全文&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p>传入的参数依然可以是比较完整的路由对象，而不只是一个拼接的字符串</p></li><li><p>$router.push 是追加跳转</p></li><li><p>$router.replace 则是更新最新的一条</p></li><li><p>命名视图 router-view - 路由中的 slot</p></li><li><p>根据设置的 name 属性展示不同的组件</p></li><li><p>也就是可以给一个 path 指定多个 命名的 components，在进入给定 path 时，router-view 和 component 按命名匹配渲染，剩下的属性就在无名的 router-view 中渲染</p></li><li><p>设置导航高亮样式</p></li><li><p>自定义 activeClass 的高亮样式会让所有父级路径一起高亮，这种只适合特定的路由分组情况</p></li><li><p>精确的 activeClass 高亮就需要设置 linkExactActiveClass 属性，并连接样式中的同名样式</p></li><li><p>导航守卫</p></li><li><p>拦截控制路由跳转</p></li><li><p>某种导航的生命周期钩子</p></li><li><p>全局配置，在 router 的全局实例中</p></li><li><p>按路由在路由对象中配置</p></li><li><p>在组件中配置，export default 中使用</p></li><li><p>全局导航</p></li><li><p>beforeEach</p><ul><li>导航触发</li><li>组件尚未加载</li><li>导航尚未实际跳转前</li><li>多为权限验证</li></ul></li><li><p>beforeResolve</p><ul><li>导航守卫执行完毕</li><li>组件加载完毕</li><li>组件中的导航守卫执行完毕</li><li>导航实际跳转前</li><li>数据加载或者特定权限操作</li></ul></li><li><p>afterEach</p><ul><li>导航确认</li><li>导航实际跳转</li><li>可以修改 DOM</li><li>埋点，发送统计数据</li></ul></li><li><p>路由导航</p></li><li><p>beforeEnter</p><ul><li>进入对应路由（url 变化）</li><li>页面未实际跳转</li><li>动态路由的动态部分变化不会触发这个守卫</li><li>对象中的 children 路由也受其控制</li></ul></li><li><p>router 中的组件中配置(一般组件不行)</p></li><li><p>beforeRouteEnter()</p><ul><li>导航跳转时</li><li>组件创建前</li><li>不能访问组件 this,但可以通过 next 来访问</li><li>只在第一次渲染时执行</li></ul></li><li><p>beforeRouteUpdate()</p><ul><li>导航跳转时</li><li>复用组件时</li><li>动态路由可以触发</li><li>可以访问组件 this</li><li>提醒用户是否真的要离开页面，表单可能要重填</li></ul></li><li><p>beforeRouteLeave()</p><ul><li>导航跳转时</li><li>组件销毁前</li><li>提醒用户保存</li></ul></li><li><p>导航守卫执行顺序</p></li><li><p>如果组件中存在 beforeRouteLeave 守卫，则第一个执行</p></li><li><p>执行全局的 beforeEach 守卫</p></li><li><p>在复用组件中执行 beforeRouteUpdate 守卫</p></li><li><p>执行路由中的 beforeEnter 守卫</p></li><li><p>解析异步的守卫</p></li><li><p>执行组件中的 beforeRouteEnter 守卫</p></li><li><p>执行全局的 beforeResolve 守卫</p></li><li><p>确认导航并进行跳转</p></li><li><p>执行全局 afterEach 守卫</p></li><li><p>更新 DOM 节点</p></li><li><p>执行组件中 beforeRouteEnter 的 next 回调中的回调</p></li><li><p>权限守卫限定路径时要注意用 startWith，这样匹配所有相关路径，不会有漏网之鱼</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const loggedIn = false; router.beforeEach((to, from) =&gt; { //console.log(from);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// console.log(to); if (to.path.startsWith(&quot;/blogs&quot;)) { if (!loggedIn) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">return &quot;/login&quot;; } // return false; // return { // name: &quot;login&quot;, // params:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x, }; } });</span></span></code></pre></div></li><li><p>生命周期钩子中的操作依然可以抽函数再以数组形式传给响应钩子</p></li><li><p>相当于一种缓慢呈现的效果</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">beforeRouteUpdate(to) { this.blog = {}; setTimeout(() =&gt; { this.blog =</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">getBlogPostById(to.params.postId); }, 1000); },</span></span></code></pre></div></li><li><p>这个思路是获取响应动态路由然后挂载到组件实例 vm 上</p></li><li><p>meta 元数据</p></li><li><p>也是配在路由对象里,查看需要在 to，from 的 match 里的 meta 看</p></li><li><p>matched 实际上是所有 meta 数据的集合</p></li><li><p>子对象 meta 不会递归合并，同名 meta 则后覆盖前</p></li><li><p>存各种自定义数据</p></li><li><p>权限验证就可以用这个来</p></li><li><p>控制滚动条</p></li><li><p>每次重新进入路由时都从把位置重置到页面开头</p></li><li><p>router 对象中有 scrollBehavior</p></li><li><p>这个 scrollBehavior 是一个对象，内容和 position 有点像，你想把页面停在哪就停在哪</p></li><li><p>还他妈支持延时滚动，将 scrollBehavior 写成函数，return 一个 promise 完事</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const router = createRouter({ history: createWebHistory(), routes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scrollBehavior(to, from, savedPosition) { return new Promise((resolve) =&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">setTimeout(() =&gt; { resolve({ top: 200, behavior: &quot;smooth&quot;, }); }, 1000) ); },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p>还可以设置 el 元素，针对具体 dom 元素偏移</p></li><li><p>还可以选择 savedPosition 参数，在前进和回退时保存页面位置数据</p></li><li><p>路由懒加载 异步组件</p></li><li><p>在组件展示时再加载</p></li><li><p>基本上就是用 const 组件名 = () =&gt; import(&#39;组件路径&#39;) 方式包裹一层再用</p></li><li><p>在 router 中给组件传递参数</p></li><li><p>在路由对象中设置 props 为 true</p></li><li><p>在相应组件页面继续承接 prop</p></li><li><p>自定义/扩展 router-link</p></li><li><p>$props 是组件实例的 prop 属性，经常可以用来指定一批变量</p></li><li><p>处理导航错误</p></li><li><p>错误主要有三种</p></li><li><p>aborted 导航被终端，或许是守卫终止了路由跳转</p></li><li><p>cancelled 导航取消，导航跳转中有新的路由跳转，例如用户连续点击多次链接</p></li><li><p>duplicated 重复导航，当前页面已经是跳转目标路由</p></li><li><p>aborted</p></li><li><p>在子组件定义一个重定向函数，存储并打印失败信息</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">async </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">redirectToManagementPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> failure</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/blogs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(failure);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isNavigationFailure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(failure));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div></li><li><p>isNavigationFailure 函数可以判断是否为标准的导航错误</p></li><li><p>也有 navigationFailure.type 做具体判断</p></li><li><p>在路由文件正常搞一个生命周期钩子做登录控制就行</p></li><li><p>如何动态添加路由</p></li><li><p>直接在组件实例中调 api</p></li><li><p>this.$route.addRoute({path, name, component})</p></li><li><p>this.$route.removeRoute(&#39;name&#39;)</p></li><li><p>或者 const removeRoute = this.$router.addRoute(); removeRoute()</p></li><li><p>路由过渡动画</p></li><li><p>用 router-view 包裹 transition，transition 再包裹动态组件</p></li><li><p>composition api 使用路由</p></li><li><p>依然变为 useRoute 函数,使用 const router = userRoute()来构建对象</p></li><li><p>相关的数据通过 useRoute().params.postId</p></li><li><p>能转换的生命周期钩子都加了 on</p></li><li><p>有些因为在 setup 之前执行，所以仍然需要选项 api</p></li></ul>`,3),n=[t];function h(e,k,E,r,o,d){return s(),a("div",null,n)}const y=i(p,[["render",h]]);export{c as __pageData,y as default};
