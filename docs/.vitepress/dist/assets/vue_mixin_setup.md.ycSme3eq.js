import{_ as i,o as a,c as e,R as t}from"./chunks/framework.OFllvWJp.js";const x=JSON.parse('{"title":"组合式 api 的出现动机和 mixin 复用的痛点","description":"","frontmatter":{},"headers":[],"relativePath":"vue/mixin&setup.md","filePath":"vue/mixin&setup.md"}'),l={name:"vue/mixin&setup.md"},s=t(`<h1 id="组合式-api-的出现动机和-mixin-复用的痛点" tabindex="-1">组合式 api 的出现动机和 mixin 复用的痛点 <a class="header-anchor" href="#组合式-api-的出现动机和-mixin-复用的痛点" aria-label="Permalink to &quot;组合式 api 的出现动机和 mixin 复用的痛点&quot;">​</a></h1><h2 id="技术考古-mixin" tabindex="-1">技术考古 mixin <a class="header-anchor" href="#技术考古-mixin" aria-label="Permalink to &quot;技术考古 mixin&quot;">​</a></h2><h3 id="定性" tabindex="-1">定性 <a class="header-anchor" href="#定性" aria-label="Permalink to &quot;定性&quot;">​</a></h3><ul><li>是一个组件，有 data，prop 等属性</li><li>就是把 script 部分 export 从大括号开始的内容，全部放在一个单独文件中备复用</li><li>可在需要时导入，在 mixin 配置项按数组传入所需 mixin 就行</li></ul><h3 id="作用规范" tabindex="-1">作用规范 <a class="header-anchor" href="#作用规范" aria-label="Permalink to &quot;作用规范&quot;">​</a></h3><ul><li>和组件原有数据相比优先级不高，有命名冲突时以组件自己的 data 为主</li><li>data 中所有数据进行合并 <ul><li>如果有重名则组件自身属性覆盖 mixin 属性</li><li>methods, computed, prop,components 中的属性同样进行合并，重名则组件覆盖 mixin</li><li>如果对象 key 相同，组件内优先</li></ul></li></ul><h3 id="生命周期钩子" tabindex="-1">生命周期钩子 <a class="header-anchor" href="#生命周期钩子" aria-label="Permalink to &quot;生命周期钩子&quot;">​</a></h3><ul><li>组件和 mixin 都执行，且 mixin 比组件先执行</li><li>所以生命周期调用都能调用</li></ul><h3 id="引入方式" tabindex="-1">引入方式 <a class="header-anchor" href="#引入方式" aria-label="Permalink to &quot;引入方式&quot;">​</a></h3><ul><li>引入组件的就是局部 mixin，引入根组件的就是全局 mixin app.mixin()</li><li>全局插件相当于把上述的配置项在所有页面注入</li><li>这种适合写插件 可以在其中给 vue 加入任意配置项，并通过 this.$options 来获取</li></ul><h3 id="minxi-的问题" tabindex="-1">minxi 的问题 <a class="header-anchor" href="#minxi-的问题" aria-label="Permalink to &quot;minxi 的问题&quot;">​</a></h3><ul><li>命名冲突</li><li>来源不明</li><li>分隔不清</li></ul><h2 id="组合式-api" tabindex="-1">组合式 API <a class="header-anchor" href="#组合式-api" aria-label="Permalink to &quot;组合式 API&quot;">​</a></h2><h3 id="setup-props-context" tabindex="-1">setup(props, context) <a class="header-anchor" href="#setup-props-context" aria-label="Permalink to &quot;setup(props, context)&quot;">​</a></h3><ul><li><p>setup 中没有 this</p></li><li><p>props 参数就能拿到所有 props 数据</p></li><li><p>context 参数能拿到 attrs，slots（父组件插槽）以及 emit（没有 this.$emit 了）</p></li><li><p>setup return 值能够被 template 使用，相当于代替 data</p></li><li><p>setup 中定义函数正常定义就行，但要记得 return 出去</p></li><li><p>setup()函数只是替代 data，computed 和 methods 这些响应式内容，components，props 和 emits 仍然使用配置项形式</p></li><li><p>不过进一步 setup 语法糖就全变成 definexxx 了</p></li></ul><h3 id="组合式的生命周期" tabindex="-1">组合式的生命周期 <a class="header-anchor" href="#组合式的生命周期" aria-label="Permalink to &quot;组合式的生命周期&quot;">​</a></h3><ul><li>setup 在 created 和 beforeCreate 之前调用，所以直接在 setup 操作就行</li><li>所有钩子前面都加 on</li><li>setup 代替了 beforeCreate 和 created 两个钩子</li><li>变为可以直接在 setup 中调用的函数</li></ul><h3 id="setup-中的-prop" tabindex="-1">setup 中的 prop <a class="header-anchor" href="#setup-中的-prop" aria-label="Permalink to &quot;setup 中的 prop&quot;">​</a></h3><ul><li>prop 配置项照样要写</li><li>但传 prop 和收 prop 的组件中都要接收 setup(prop)参数</li><li>并且使用 prop.xxx 方式读取 prop</li></ul><h3 id="如何将非响应性-prop-转换为响应性" tabindex="-1">如何将非响应性 prop 转换为响应性 <a class="header-anchor" href="#如何将非响应性-prop-转换为响应性" aria-label="Permalink to &quot;如何将非响应性 prop 转换为响应性&quot;">​</a></h3><ul><li>父组件向子组件传递的响应性 prop 在子组件也是响应性的，无论是否进行解构</li><li>template 会对响应性数据自动进行拆解，把 ref.value 拿出来，所以数据会变为 proxy 而非 refimpl</li><li>传递 js 基本类型数据时会失去响应性，乖乖地用 torefs</li><li>传递对象时就完全不怕，但如果用 ref 包裹</li></ul><h3 id="context-参数" tabindex="-1">context 参数 <a class="header-anchor" href="#context-参数" aria-label="Permalink to &quot;context 参数&quot;">​</a></h3><ul><li>setup 的第二个参数是 context，context 中有两个主要属性</li></ul><p>slots 属性</p><ul><li>slots 成为一个对象，需要在 setup 传入解构参数 setup(props, {slots})保存了组件中传入的 slots 信息，属性名就是名字，属性值成为函数</li><li>在组合式 api 中使用需要 return 一个回调函数来调用 h 函数</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;header&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {}, slots.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>attrs</p><ul><li><p>使用同 slots setup(props, {attrs})</p></li><li><p>包括所有没有明确定义的其他属性（比如 data-xxx）， 替代 $attrs 属性,模板中可以使用 this 来使用</p></li><li><p>本身是响应性的，和 prop 一样不能随便解构 setup 中的 emit</p></li><li><p>因为无法使用 this，所以 watch 和 emit 时要其他办法</p></li><li><p>在 子组件 setup 定义的函数中套 emit(&quot;name&quot;, params)函数来发射事件，同时在 emits 配置项里也要这么写</p></li><li><p>并在父组件中监听 emit 发射的事件</p></li><li><p>不过在模板中可以更随意一点用$emit</p></li></ul><h3 id="组合式中的-provide-和-inject" tabindex="-1">组合式中的 provide 和 inject <a class="header-anchor" href="#组合式中的-provide-和-inject" aria-label="Permalink to &quot;组合式中的 provide 和 inject&quot;">​</a></h3><ul><li>均变为函数，provide(&#39;propName&#39;, value)提供, const xxx = inject(&#39;propName&#39;)来接收</li><li>响应式数据也保持响应性，同样需要注意解包和深层数据响应性的问题</li></ul><h3 id="setup-源码的执行顺序" tabindex="-1">setup 源码的执行顺序 <a class="header-anchor" href="#setup-源码的执行顺序" aria-label="Permalink to &quot;setup 源码的执行顺序&quot;">​</a></h3><ul><li>createComponentInstance 创建组件实例</li><li>setupComponent 初始化 component 内部操作</li><li>setupStatefulComponent 初始化有状态组件</li><li>在 setupStatefulComponent 取出 setup 函数</li><li>callWithErrorHanding 执行 setup</li></ul>`,32),p=[s];function r(n,o,h,u,d,c){return a(),e("div",null,p)}const k=i(l,[["render",r]]);export{x as __pageData,k as default};
