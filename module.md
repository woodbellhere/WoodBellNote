模块的导入和导出

- 因为所有内容都在私有作用域中，需要明确引入和导出
- 导出方式
  - export 和 import + 各类声明 let function class 等
  - export 和 import + 声明好的变量名 {xxx1, xxx2,xxxx}
  - 可在 export 和 import 时赋予别名 export {xxx1 as yyy1}
  - export default 的对象成为默认导出，导入时则默认接收这部分内容
    - 一种经验是 export xxx 给整个模块起个喜欢的名字，这样 导入时就可以随你喜欢
- 导入和导出时的大括号
  - 不是对象语法，而是特定的模块语法，导出不是对象字面量，引入也不是解构
  - export default + 大括号，基本就是一个对象了
- 引入方式
  - import \* as xxx from './xxx' 获取模块全部内容并放入 xxx 对象中
  - 命名成员正常 {}引入
  - 默认成员需要用 as，也可以在{}外直接引入
  - 命名成员和默认成员可以在{}中按要求同时导入，也可以在{}内外分别引入
  - import defaultX, {xxx1, xxx2} from './xxx'
- 导入导出是复制还是引用
  - 是引用，在引入处表现为只读常量，无法修改
  - 可以通过在导入和导出处各自一个定时器检查读写变化来实现
- 引入的地址要求
  - 必须把后缀/扩展名写全，只是在打包工具支持下可以省略
  - 需要补全./或者使用/xxx 指定根目录
  - 可以指定一个完整的网络 url，可以引 cdn
  - 通过引入运行模块，而非使用具体的数据
    - import {} from './xxx'即可只运行模块
    - 可简写为 import './xxx' 直接省略指定数据部分
- 动态引入与引入的条件和时机
  - import from 实际是静态的，不能在运行时根据条件判断按需引入
  - import()函数实现了这个功能
- 导入后直接导出
  - export {xxx1, xxx2} from './xxx'
- 集中导出的开发经验

  - 当需要导入导出的数据较为繁琐时
  - 可以在某个文件（比如 index.js）中集中导入再导出
